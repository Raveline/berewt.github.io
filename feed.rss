<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Codice and Circenses</title>
        <link>http://nicolas.biri.name/</link>
        <description><![CDATA[IT, Programming, boardgames and random thoughts]]></description>
        <atom:link href="http://nicolas.biri.name//feed.rss" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 17 Aug 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Ne plus être le produit</title>
    <link>http://nicolas.biri.name//posts/2016-08-17-Ne-plus-etre-un-produit.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 17, 2016
    
        by Nicolas Biri
    
</div>

<p>Aujourd’hui, sur ma timeline twitter, a circulé un article de la quadrature intitulé “<a href="https://www.laquadrature.net/fr/si-vous-etes-le-produit">Si vous êtes le produit, ce n’est pas gratuit</a>”. Je suis très souvent critique sur la forme des prises de positions de la quadrature, que je trouve trop souvent enfermée dans une opposition caricaturale. Cet article est pire, car il est rempli d’arguments que je trouve, faux, injustes et mensongers. Du coup, je prends le temps d’expliquer pourquoi.</p>
<h1 id="le-modèle-commercial-gratuit">Le modèle commercial “gratuit”</h1>
<p>La premier partie, très juste, critique le mantra “si c’est gratuit, c’est vous le produit” et propose d’y substituer le plus juste “si vous êtes le produit, ce n’est pas gratuit”.</p>
<p>Jusque là, tout va bien.</p>
<p>Et là, à peine plus loin, on commence à s’éloigner de ce que je juge pertinent :</p>
<blockquote>
<p>vous acceptez des contrats d’utilisation léonins qui font de vous une main d’œuvre sans droit ni titre, vous acceptez d’être pistés, tracés, traqués pour que le client final (généralement une régie publicitaire) sache tout de vous pour mieux vous cibler.</p>
</blockquote>
<p>Le choix du vocabulaire fait tout pour placer le consommateur de services monétisant le contenu de ses utilisateurs et vivant de la publicité comme une victime. Je comprends que l’on rappelle quel est le mode de fonctionnement de ces sociétés, la limitation des droits que le contrat d’utilisation implique.</p>
<p>Il est toutefois important de rappeler que beaucoup, en conscience, acceptent ces contraintes. Parce qu’ils estiment que la contrepartie fait que l’accord est bon. Prenons mon cas, je suis un gros utilisateur de Twitter, service commercial qui utilise le contenu que je publie pour déterminer quelles publicités peuvent m’intéresser et qui a droit de vie et de mort sur mon compte. Je le sais et je l’accepte. Et je ne me sens ni traqué, ni ciblé, ni signataire d’un contrat léonins.</p>
<p>Il y a, chez les défenseurs des libertés, une volonté de convaincre les gens qu’il ne <strong>faut</strong> pas utiliser ces services qui m’a toujours gêné.</p>
<h1 id="lescroquerie-de-laccusation-de-vol">L’escroquerie de l’accusation de vol</h1>
<p>Continuons avec une instance de service qui monétise les données de ses utilisateurs avec l’exemple de uacebook. Je me permets de recopier complètement le passage concerné :</p>
<blockquote>
<p>Dans une conférence d’il y a longtemps, j’expliquais que Facebook était le plus grand voleur que je connaisse. Pour résumer : Facebook publie vos contenus (sans vous payer) pour attirer du public vers les écrans de publicité qu’il vend. Il revend (sans les payer) vos données personnelles à ses clients (les régies publicitaires) pour qu’elles puissent mieux vous cibler. Puis il vous propose – à vous – de payer pour que vos contenus soient plus visibles que les autres (et donc pour attirer plus de visiteurs vers les écrans de pub de ses clients), avant finalement de vous proposer d’acheter ses actions pour espérer enfin toucher une part du fric que votre travail rapporte.</p>
</blockquote>
<p>C’est là que je me suis dit que non, jamais je ne pourrais supporter la quadrature. Je n’aime pas Facebook, j’y ai un compte dormant mais j’utilise très peu le service. Pourtant, je peux affirmer sans crainte que tout ce passage est la charge la plus honteuse et malhonnête que j’ai pu lire sur ce service. Détaillons.</p>
<ul>
<li><q>Facebook publie vos &gt; contenus (sans vous payer) pour attirer du public vers les écrans de publicité qu’il vend.</q> : Oui, Facebook ne vous paye pas. Facebook vous rend un <em>service</em> qu’il paye avec la publicité. Ce service est de vous permettre de publier votre contenu et de le rendre disponible à vos contacts. Si vous jugez que ce service n’en vaut pas la peine, libre à vous de vous en passer.</li>
<li><q>Il revend (sans les payer) vos données personnelles à ses clients (les régies publicitaires) pour qu’elles puissent mieux vous cibler.</q> Oui. ça fait partie là aussi de la contrepartie pour le service rendu.</li>
<li></q>Il vous propose – à vous – de payer pour que vos contenus soient plus visibles que les autres.</q> Si vous payez, c’est soit que vous estimez que votre contenu est tellement intéressant qu’il doit être visible, soit que vous espérez que ça soit rentable pour vous. Dans tous les cas, si vous <em>décidez</em> de donner votre argent à Facebook, c’est que la contrepartie vous semble intéressante. On est loin du vol.</li>
</ul>
<p>Bref, parce que l’auteur ne juge pas le service intéressant par rapport ses exigences et attentes, Facebook est un voleur, le plus grand voleur. J’ai pour ma part l’impression que la contrepartie offerte par Facebook est plus intéressante que celle offerte dans toutes les histoires de vol que j’ai entendu.</p>
<p><q>Et vous en redemandez.</q> Il est toujours bon de souligner les phrases anodines qui tentent de prendre l’ascendant sur le lecteur : si vous utilisez un service qui vous vole, vous n’êtes pas bien malin.</p>
<h1 id="linjustice-des-mesures-anti-blocage">L’injustice des mesures anti-blocage</h1>
<p>Si on parle de Facebook, ce n’est pas juste pour vomir sur leur service, c’est également pour dénoncer les mesures anti-adblock prisent par le site : Facebook a visiblement depuis quelques temps modifier son code pour passer aux travers des filtres des bloqueurs de publicité.</p>
<p>Visiblement c’est choquant. Très. Plus que l’existence de logiciel qui bloquent la publicité. Laissons de coté pour le moment ce que je pense de la publicité sur internet. Si on trouve normal que les gens essaient de ne pas afficher les publicités, ne doit-on pas trouver également normal que les sites dont c’est le fond de commerce essaient d’être plus malin qu’eux ? Je dirais que si, mais je ne suis pas un expert des libertés (car visiblement, c’est de ça dont il s’agit.)</p>
<p>Ce préambule mis en place, regardons ce que l’article nous dit du modèle de la publicité sur internet. <q>Elle est devenue envahissante au point d’avoir suscité l’émergence des dits ad-blockers.</q> C’est un point de vue. On peut aussi juger que ce qui a popularisé les ad-blockers, c’est la volonté de continuer à utiliser des sites dont on ne supportait pas la logique commerciale. Le dire comme ça, c’est malheureusement culpabiliser l’utilisateur plutôt que le site et ça ne nous arrange pas. C’est donc mal.</p>
<p><q>le modèle économique « publicité contre fausse gratuité » est devenu tel qu’il remet en cause un tas de libertés fondamentales.</q> Et c’est reparti.</p>
<p><q>La liberté d’expression (il faut que l’espace publicitaire reste assez propre pour attirer les annonceurs, cachez ce sein qu’ils ne sauraient voir).</q> Alors autant je trouve la censure de Facebook, entre autres, ridicule, autant y associer la liberté d’expression me troue le cul. Donc non, on ne publie pas sur un site tiers ce qu’on veut, ça fait là aussi partie du compromis que l’on accepte en utilisant le service. Oui, je trouve honteux que Facebook soit choqué par l’érotisme. Mais je le sais, c’est connu et ce n’est pas une putain d’entrave à la liberté d’expression. Un nichon qui est censuré par facebook aura sa place dans plein d’autres endroit du web. Je trouve également cocasse d’estimer que ne pas pouvoir publier sur Facebook est synonyme d’entrave à la liberté d’expression, c’est donner beaucoup de pouvoir à un site qui est le plus grand des voleurs.</p>
<h1 id="les-ad-blocks-et-la-pause-pipi">Les ad-blocks et la pause pipi</h1>
<p>Le coup de grâce, dans ce tombereau d’inepties, vient quand on finit par comparer un ad-blocker à une pause pipi devant la télé. Pas le pire, certes, mais la fatigue aidant, un argument à la con en plus passe mal. Il s’agit tout d’abord de comparer internent, un média essentiellement écrit (surtout avec l’exemple cité de Facebook), à un média exclusivement vidéo. Ensuite, quand vous allez aux toilettes, la publicité passe quand même, pas quand vous la bloquez. Enfin, la télévision à plein d’astuces pour vous incitez à regarder la publicité (coupure avant un moment crucial, mini pause par exemple.) Il n’y a pas de comparaison sur internet… Ah si, contourner l’ad-blocker, cette idée même qui choque l’auteur.</p>
<h1 id="ma-relation-à-la-publicité-sur-internet">Ma relation à la publicité sur internet</h1>
<p>Je n’utilise plus d’ad-blocker depuis plusieurs années, j’utilise uniquement un tracker (<a href="https://www.ghostery.com">ghostery</a>), pour éviter aux sites de me pister.</p>
<p>Je n’utilise pas d’ad-blocker parce que j’estime que si je visite un site, je me dois d’accepter le contrat implicite qui me lie à ce site. De plus, cela à un gros avantage : si un site place trop de publicité, je m’en rends compte et j’arrête de m’y rendre. C’est la façon la plus saine pour ne pas encourager des pratiques commerciales qu’on désapprouve.</p>
<p>En revanche, j’utilise un outil anti-tracking car si j’accepte le contrat implicite qui me lie au site que je visite, je refuse d’accepter celui des sites qu’il intègre si je ne décide pas explicitement de les visiter.</p>
<p>Il est peut-être important vu la teneur de ce qui précède de bien souligner qu’il s’agit de ma façon d’interagir, pas de ce que j’estime nécessaire que tout le monde fasse.</p>
]]></description>
    <pubDate>Wed, 17 Aug 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-08-17-Ne-plus-etre-un-produit.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>
<item>
    <title>Union Type in Idris (Part 5)</title>
    <link>http://nicolas.biri.name//posts/2016-08-14-union-type-in-idris-part-5.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 14, 2016
    
        by Nicolas Biri
    
</div>

<p>Go back to the <a href="http://nicolas.biri.name/posts/2016-07-26-union-type-in-idris-part-1.html">first part</a>.</p>
<h1 id="unit-and-property-testing-in-idris">Unit and property testing in Idris</h1>
<p>I thought I was done with the union type series, but then I think about how great this example is to demonstrate some of the possibilities of test and property checking in Idris.</p>
<p>Idris has a <a href="http://docs.idris-lang.org/en/latest/tutorial/testing.html">basic testing framework</a>. I won’t discuss it here. As Idris is very young, the framework has little interest at this time and we can do way better (in my opinion) by just using types in a clever way.</p>
<h2 id="unit-testing-at-compile-time">Unit testing at compile time</h2>
<p>As types are a first class language construct in Idris, you can use value to build type. An interesting type constructor is <code>=</code>. The type <code>a = b</code> is populated by the proof that <code>a</code> is euqal to be <code>b</code>. To construct inhabitants of this class, we often use <code>Refl</code>, which is an inhabitant of <code>a = a</code> (We already used Refl in the definitions of isomorphisms in <a href="http://nicolas.biri.name/posts/2016-08-14-union-type-in-idris-part-4.html">part 4</a>.)</p>
<p>This can be used to define unit testing functions, that will be resolved at compile time. If we go back to the definition of <code>Union</code> and ot the <code>member</code> constructor</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Union</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">MemberHere</span> <span class="ot">:</span> ty <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>ts)
  <span class="dt">MemberThere</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>ts)

<span class="fu">member</span> <span class="ot">:</span> ty <span class="ot">-&gt;</span> {<span class="kw">auto</span> e<span class="ot">:</span> <span class="dt">Elem</span> ty ts} <span class="ot">-&gt;</span> <span class="dt">Union</span> ts
member x {e <span class="fu">=</span> <span class="dt">Here</span>} <span class="fu">=</span> <span class="dt">MemberHere</span> x
member x {e <span class="fu">=</span> <span class="dt">There</span> later} <span class="fu">=</span>
  <span class="dt">MemberThere</span> (member x {e <span class="fu">=</span> later})</code></pre></div>
<p>We can quickly set up some tests:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">memberCreateMemberHereTest</span> <span class="ot">:</span>
  the (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>]) (member <span class="st">&quot;Foo&quot;</span>) <span class="fu">=</span>
  <span class="dt">MemberHere</span> <span class="st">&quot;Foo&quot;</span>
memberCreateMemberHereTest <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>and:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">memberCreateMemberThereTest</span> <span class="ot">:</span>
  the (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>]) (member <span class="dv">42</span>) <span class="fu">=</span>
  <span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> <span class="dv">42</span>)
memberCreateMemberThereTest <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>These tests will be executed at compile time and will pass if our definition are correct. No need for a framework.Moreover, if we ship a faulty version without testing, thrd users won’t be able to use the library because they won’t be able to compile our code.</p>
<h1 id="theorem-proving-or-enhanced-property-testing">Theorem proving (or enhanced property testing)</h1>
<p>Tests prove that your definitions are correct for some values, theorem prove that it’s correct for all values. Even with something as simple as the <code>Union</code> library, we can prove fancy stuff.</p>
<h2 id="lets-get-a-member">Let’s <code>get</code> a <code>member</code></h2>
<p>First, let’s recall the definition of <code>get</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">get</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> {<span class="kw">auto</span> p<span class="ot">:</span> <span class="dt">Elem</span> ty ts} <span class="ot">-&gt;</span> <span class="dt">Maybe</span> ty
get (<span class="dt">MemberHere</span> x)      {p <span class="fu">=</span> <span class="dt">Here</span>}      <span class="fu">=</span> <span class="dt">Just</span> x
get (<span class="dt">MemberHere</span> x)      {p <span class="fu">=</span> <span class="dt">There</span> <span class="fu">_</span>}   <span class="fu">=</span> <span class="dt">Nothing</span>
get (<span class="dt">MemberThere</span> x)     {p <span class="fu">=</span> <span class="dt">Here</span>}      <span class="fu">=</span> <span class="dt">Nothing</span>
get (<span class="dt">MemberThere</span> later) {p <span class="fu">=</span> (<span class="dt">There</span> l)} <span class="fu">=</span> get later {p <span class="fu">=</span> l}</code></pre></div>
<p>It’s quite natural to see <code>get</code> as the <em>invert</em> of <code>member</code>. Let’s formalise it with some properties.</p>
<p>To warm up, we’ll write a first one that just work for a trivial case: one type union. We want to check that if we build a one typ uninon with <code>member</code> and <code>get</code> ot back, we obtain <code>Just</code>. It’s as simple as writing this description:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">getHereMemberIsJust</span> <span class="ot">:</span> (x <span class="ot">:</span> a) <span class="ot">-&gt;</span> get (member x) <span class="fu">=</span> <span class="dt">Just</span> x
getHereMemberIsJust <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>Let’s go further and prove something similar for more complex unions. To do so, we must be able to reason on <em>which type</em> we populated. To do so, we will make the <code>Elem ty ts</code> implicit parameter of <code>member</code> and <code>get</code> explicit.</p>
<p>If we create a union with <code>member</code> at a place given by <code>Elem ty ts</code> and check the value at the same place with <code>get</code>, we should have <code>Just</code> the value:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">getMemberWithElemIsJust</span> <span class="ot">:</span>
  (x <span class="ot">:</span> a) <span class="ot">-&gt;</span>
  (p <span class="ot">:</span> <span class="dt">Elem</span> a xs) <span class="ot">-&gt;</span>
  the (<span class="dt">Maybe</span> a) (get (member x {p}) {p}) <span class="fu">=</span> <span class="dt">Just</span> x</code></pre></div>
<p>This prove is trickier thant the previous one. It should be proved by induction on <code>p</code>. The base case is easy. if <code>p = Here</code>, the compiler will reduce both part of the equality by itself and we only has to prove a straight forward equality:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">getMemberWithElemIsJust <span class="fu">_</span> <span class="dt">Here</span> <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>The induction case is quite easy too now thanks to the previous case hypothesis.</p>
<p>It’s time for me to introduce the interactive proof facilities of Idris. Actually, I should have done it way earlier but it’s one of this thing that seems so natural to use that you forgot to mention how great it is.</p>
<p>The Idris REPL, and many compatible editors, provide some helpful command to ease type driven development. One of them is being able to define <em>holes</em> in your code and to check their type. More details about TDD and interactive development in Idris can be found in the <a href="http://docs.idris-lang.org/en/latest/tutorial/interactive.html">online documentation</a> or in the excellent <a href="https://www.manning.com/books/type-driven-development-with-idris">Idris book</a>.</p>
<p>Now that you know it, we can use hole in our induction case:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">getMemberWithElemIsJust x (<span class="dt">There</span> later) <span class="fu">=</span> <span class="ot">?wut</span></code></pre></div>
<p><code>?wut</code> is our hole, and if we ask to the compiler its type, we obtain:</p>
<pre><code>  a : Type
  x : a
  xs : List Type
  later : Elem a xs
  y : Type
--------------------------------------
wut : get (member x) = Just x</code></pre>
<p>Idris provides a recap of all the types in the context, and display the expected type for <code>wut</code>. With the context information, Idris was able, by itself, to reduce <code>wut</code> to the type of the induction hypothesis. Thus, we just have to provide it:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">getMemberWithElemIsJust x (<span class="dt">There</span> later) <span class="fu">=</span>
  getMemberWithElemIsJust x later</code></pre></div>
<p>And that’s it. We have a complete proof that if we put a value at a given place of a union and if we get the value at the same place, we obtain <code>Just</code> this value.</p>
<h1 id="the-difficulty-of-theorem-proving-digression">The difficulty of theorem proving (digression)</h1>
<p>The above proofs are almost trivial when you are used to types and to theorem proving. However, it may be hard to grasp for newcomers. Actually, these small examples can be used to illustrate the difficulties encountered by the advocates of formally proved code to convince developpers and the industry.</p>
<p>To be honest, I had few experiences with formal proof education to devleopers. However, during these experiences, I encountered two majors objections:</p>
<ol style="list-style-type: decimal">
<li>The properties I want to test are not complex enough to require a whole proof, proving that it works for some values, or for a set of random value is sufficient.</li>
<li>When I have to encode a proof, I have to formalize a work that I have already done mentally when I wrote the code, in a non-natural way.</li>
</ol>
<p>Both objections are unfortunately valid in most cases. We can however mitigates this feeling by:</p>
<ol style="list-style-type: decimal">
<li>What if, for almost the same costs, as unit or properties tests, you can be sure that it is valid for all the values.</li>
<li>Providing helpful enough programing environment to mae the formalisation process as natural as possible.</li>
</ol>
<p>Moreover, I should emphasize one of the major advantages of formal proof embedded in a library, that I’ve already mentioned in the article. These proofs of properties can be seen as a contract that my library ensure to respect. It offers garantees about third party code and thus can higly reduce the lack of confidence that I can have in those libraries.</p>
]]></description>
    <pubDate>Sun, 14 Aug 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-08-14-union-type-in-idris-part-5.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>
<item>
    <title>Union Type in Idris (Part 4)</title>
    <link>http://nicolas.biri.name//posts/2016-08-02-union-type-in-idris-part-4.html</link>
    <description><![CDATA[<div class="info">
    Posted on August  2, 2016
    
        by Nicolas Biri
    
</div>

<p>Go back to the <a href="http://nicolas.biri.name/posts/2016-07-26-union-type-in-idris-part-1.html">first part</a>.</p>
<h1 id="a-glimpe-of-equality">A glimpe of equality</h1>
<p>Idris handles equality with a typeclass, just like Haskell. Whilst equality must be define specifically for each sum type, we can define the equality in a generic manner for union types. The idea is to define the equality iteratively on the list of types of the union.</p>
<h2 id="equality-for-union-xxs">Equality for <code>Union x::xs</code></h2>
<p>Let’s start with the recursive case, do we really need to elaborate?</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">(<span class="dt">Eq</span> ty, <span class="dt">Eq</span> (<span class="dt">Union</span> xs)) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Union</span> (ty<span class="ot">::</span>xs)) <span class="kw">where</span>
  (<span class="fu">==</span>) (<span class="dt">MemberHere</span> x) (<span class="dt">MemberHere</span> y) <span class="fu">=</span> x <span class="fu">==</span> y
  (<span class="fu">==</span>) (<span class="dt">MemberHere</span> x) (<span class="dt">MemberThere</span> y) <span class="fu">=</span> <span class="dt">False</span>
  (<span class="fu">==</span>) (<span class="dt">MemberThere</span> x) (<span class="dt">MemberHere</span> y) <span class="fu">=</span> <span class="dt">False</span>
  (<span class="fu">==</span>) (<span class="dt">MemberThere</span> x) (<span class="dt">MemberThere</span> y) <span class="fu">=</span> x <span class="fu">==</span> y</code></pre></div>
<p>We need equality for the previous union (induction) nd for the newly added type. Then, two terms are equal if they point to the same type and have the same value.</p>
<h2 id="the-base-case">The base case</h2>
<p>Things here are a little trickier. We nned an instance of <code>Eq (Union [])</code>. Let’s look back at the <code>Union</code> definition:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Union</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">MemberHere</span> <span class="ot">:</span> (x<span class="ot">:</span> ty) <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>xs)
  <span class="dt">MemberThere</span> <span class="ot">:</span> (x<span class="ot">:</span> <span class="dt">Union</span> xs) <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>xs)</code></pre></div>
<p>Do you see the potential issue? None of them allow us to build a <code>Union []</code>. It’s impossible to build an element of <code>Union []</code>? Just explain it to Idris:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Eq</span> (<span class="dt">Union</span> []) <span class="kw">where</span>
  (<span class="fu">==</span>) (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="fu">_</span> <span class="kw">impossible</span>
  (<span class="fu">/=</span>) (<span class="dt">MemberThere</span> <span class="fu">_</span>) <span class="fu">_</span> <span class="kw">impossible</span></code></pre></div>
<p>Profit:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;foo&quot;</span> <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;foo&quot;</span>
<span class="dt">True</span> <span class="ot">:</span> <span class="dt">Boolean</span>
<span class="fu">&gt;</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;foo&quot;</span> <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;bar&quot;</span>
<span class="dt">False</span> <span class="ot">:</span> <span class="dt">Boolean</span>
<span class="fu">&gt;</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;foo&quot;</span> <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="dv">42</span>
<span class="dt">False</span> <span class="ot">:</span> <span class="dt">Boolean</span></code></pre></div>
<h2 id="uninhabited-types">Uninhabited types</h2>
<p>There is an alternative to the <code>impossible</code> solution. We can claim that a type is uninhabited thanks to a typeclass:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Uninhabited</span> (<span class="dt">Union</span> []) <span class="kw">where</span>
    uninhabited (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="kw">impossible</span>
    uninhabited (<span class="dt">MemberThere</span> <span class="fu">_</span>) <span class="kw">impossible</span></code></pre></div>
<p><code>Uninhabited</code> comes with an <code>absurd</code> funciton of type <code>Uninhabited e =&gt; e -&gt; a</code> absurd can be read as: if we have an instance of an uninhabited type, we can build anything from it.</p>
<p>Thanks to <code>Uninhabited</code>, our instance of <code>Eq</code> can be written:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Eq</span> (<span class="dt">Union</span> []) <span class="kw">where</span>
  (<span class="fu">==</span>) x <span class="fu">_</span> <span class="fu">=</span> absurd x</code></pre></div>
<h1 id="unions-and-synonyms">Unions and synonyms</h1>
<p>If our unions are well defined, a union of a unique type should be isomorphic to this type. A union of two types should be isomorphic to <code>Either</code>. Let’s transform these assumptions into proofs.</p>
<h2 id="morphisms">Morphisms</h2>
<p>The morphisms can be implemented as instances of the <code>Cast</code> typeclass and are straightforward as soon as we know how to deal with uninhabited types:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Cast</span> (<span class="dt">Union</span> [ty]) ty <span class="kw">where</span>
  cast (<span class="dt">MemberHere</span> x) <span class="fu">=</span> x
  cast (<span class="dt">MemberThere</span> x) <span class="fu">=</span> absurd x

<span class="dt">Cast</span> l (<span class="dt">Union</span> [l]) <span class="kw">where</span>
  cast x <span class="fu">=</span> (<span class="dt">MemberHere</span> x)

<span class="dt">Cast</span> (<span class="dt">Union</span> [l, r]) (<span class="dt">Either</span> l r) <span class="kw">where</span>
  cast (<span class="dt">MemberHere</span> x) <span class="fu">=</span> <span class="dt">Left</span> x
  cast (<span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> x)) <span class="fu">=</span> <span class="dt">Right</span> x
  cast (<span class="dt">MemberThere</span> (<span class="dt">MemberThere</span> x)) <span class="fu">=</span> absurd x

<span class="dt">Cast</span> (<span class="dt">Either</span> l r) (<span class="dt">Union</span> [l, r]) <span class="kw">where</span>
  cast (<span class="dt">Left</span> x) <span class="fu">=</span> (<span class="dt">MemberHere</span> x)
  cast (<span class="dt">Right</span> x) <span class="fu">=</span> (<span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> x))</code></pre></div>
<h2 id="put-an-iso-in-our-morphisms">Put an iso in our morphisms</h2>
<p>Idris has a <code>Iso</code> type, that is use to prove that two types are isomorphic. Here is its definition:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Iso</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>
  <span class="dt">MkIso</span> <span class="ot">:</span> (to <span class="ot">:</span> a <span class="ot">-&gt;</span> b)
        <span class="ot">-&gt;</span> (from <span class="ot">:</span> b <span class="ot">-&gt;</span> a)
        <span class="ot">-&gt;</span> (toFrom <span class="ot">:</span> (y <span class="ot">:</span> b) <span class="ot">-&gt;</span> to (from y) <span class="fu">=</span> y)
        <span class="ot">-&gt;</span> (fromTo <span class="ot">:</span> (x <span class="ot">:</span> a) <span class="ot">-&gt;</span> from (to x) <span class="fu">=</span> x)
        <span class="ot">-&gt;</span> <span class="dt">Iso</span> a b</code></pre></div>
<p><code>to</code> and <code>from</code> are the two morphisms used to build the isomorphism. <code>toFrom</code> and <code>fromTo</code> are proofs. They are populated if and only if for (<code>to . from</code>) and (<code>from . to</code>) behave like the <code>id</code> function.</p>
<p>Thus, being able to build an instance of <code>Iso a b</code> is a proof that <code>a</code> and <code>b</code> are isomorphic. Let’s buils these instances for <code>Union</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">oneTypeUnion</span> <span class="ot">:</span> <span class="dt">Iso</span> (<span class="dt">Union</span> [ty]) ty
oneTypeUnion <span class="fu">=</span> <span class="dt">MkIso</span> cast cast toFrom fromTo
  <span class="kw">where</span>
    toFrom <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberThere</span> x) <span class="fu">=</span> absurd x</code></pre></div>
<p>And:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">eitherUnion</span> <span class="ot">:</span> <span class="dt">Iso</span> (<span class="dt">Union</span> [l, r]) (<span class="dt">Either</span> l r)
eitherUnion <span class="fu">=</span> <span class="dt">MkIso</span> cast cast toFrom fromTo
  <span class="kw">where</span>
    toFrom (<span class="dt">Left</span> <span class="fu">_</span>) <span class="fu">=</span> <span class="dt">Refl</span>
    toFrom (<span class="dt">Right</span> <span class="fu">_</span>) <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> <span class="fu">_</span>)) <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberThere</span> (<span class="dt">MemberThere</span> x)) <span class="fu">=</span> absurd x</code></pre></div>
<p><code>Refl</code> is a member of the type <code>x = x</code>. Being able to compile this code build a formal proof of the existence of the isomorphisms.</p>
<h1 id="part-4-is-over">Part 4 is over</h1>
<p>In the <a href="http://nicolas.biri.name/posts/2016-08-14-union-type-in-idris-part-5.html">next part</a>, we’ll discuss union type testing. And, by the way, the code is <a href="https://github.com/berewt/UnionType">on github</a>.</p>
]]></description>
    <pubDate>Tue, 02 Aug 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-08-02-union-type-in-idris-part-4.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>
<item>
    <title>Union Type in Idris (Part 3)</title>
    <link>http://nicolas.biri.name//posts/2016-07-28-union-type-in-idris-part-3.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 28, 2016
    
        by Nicolas Biri
    
</div>

<p>Go back to the <a href="http://nicolas.biri.name/posts/2016-07-26-union-type-in-idris-part-1.html">first part</a>.</p>
<h1 id="some-are-better-than-others-union-is-better-than-sum">Some are better than others, Union is better than sum</h1>
<p>At this point, we have a slightly less complex syntax than sum types (with some drawbacks, but I will detail them in another part), but did we have other benefits?</p>
<p>Well, yes.</p>
<p>Today, we are going to inverstigate how flexible union types are. More precisely, I will detail union type restrictions and generalisation.</p>
<h1 id="shrink-my-union">Shrink my union</h1>
<p>Let suppose that we have a variable <code>x</code> of type <code>Union [Nat, String, List String]</code> and the following repl session:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;</span> the (<span class="dt">Maybe</span> <span class="dt">Nat</span>) x
<span class="dt">Nothing</span> <span class="ot">:</span> <span class="dt">Maybe</span> <span class="dt">Nat</span></code></pre></div>
<p>We know that <code>x</code> does not contain a <code>Nat</code>. Thus, <code>x</code> contains either a <code>String</code> or a <code>List String</code>. Well, we can explicitly express it with union types.</p>
<p>Let’s compute the type of this reasoning. Given an union instance, we can either get a value of a type in this uion or we can restrict the union. Quite clear and easy to write:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">retract</span> <span class="ot">:</span> <span class="dt">Union</span> xs <span class="ot">-&gt;</span> {<span class="kw">auto</span> p<span class="ot">:</span> <span class="dt">Elem</span> ty xs}
                   <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Union</span> (dropElem xs p)) ty</code></pre></div>
<p>The result type may require some explanations. The presence of <code>Either</code> and the right case (<code>ty</code>) is clear. The left case (<code>dropElem xs p</code>) is straightforward if we look at the <a href="http://www.idris-lang.org/docs/current/base_doc/docs/Data.List.html#Data.List.dropElem"><code>dropElem</code> documentation</a>: it removes the element pointed by <code>p</code> from the list.</p>
<p>The implementation is almost as easy to write as the type:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">retract</span> <span class="ot">:</span> <span class="dt">Union</span> xs <span class="ot">-&gt;</span> {<span class="kw">auto</span> p<span class="ot">:</span> <span class="dt">Elem</span> ty xs}
                  <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Union</span> (dropElem xs p)) ty
retract (<span class="dt">MemberHere</span> x) {p <span class="fu">=</span> <span class="dt">Here</span>} <span class="fu">=</span> <span class="dt">Right</span> x
retract (<span class="dt">MemberHere</span> x) {p <span class="fu">=</span> (<span class="dt">There</span> <span class="fu">_</span>)} <span class="fu">=</span>
  <span class="dt">Left</span> (<span class="dt">MemberHere</span> x)
retract (<span class="dt">MemberThere</span> x) {p <span class="fu">=</span> <span class="dt">Here</span>} <span class="fu">=</span>
  <span class="dt">Left</span> x
retract (<span class="dt">MemberThere</span> x) {p <span class="fu">=</span> (<span class="dt">There</span> later)} <span class="fu">=</span>
  either (<span class="dt">Left</span> <span class="fu">.</span> <span class="dt">MemberThere</span>)
         <span class="dt">Right</span>
         <span class="fu">$</span> retract x {p <span class="fu">=</span> later}</code></pre></div>
<p>The 3 first cases are trivial, they can almost be completed automatically by Idris (I should talk about this really cool feature in a next post). The last case is a bit more complex. The idea is to <em>lift</em> the result of retract to the next step: on a right, propagate the found value, on a left, just buried it one step further.</p>
<p>It’s time to see retract in action:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;</span> <span class="ot">:</span><span class="kw">let</span> x <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="fu">$</span> member <span class="st">&quot;foo&quot;</span>
<span class="fu">&gt;</span> the (<span class="dt">Either</span> <span class="fu">_</span> <span class="dt">Nat</span>) <span class="fu">$</span> retract x
<span class="dt">Left</span> (<span class="dt">MemberHere</span> <span class="st">&quot;foo&quot;</span>) <span class="ot">:</span> <span class="dt">Either</span> (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="dt">Nat</span>
<span class="fu">&gt;</span> the (<span class="dt">Either</span> <span class="fu">_</span> <span class="dt">String</span>) <span class="fu">$</span> retract x
<span class="dt">Right</span> <span class="st">&quot;foo&quot;</span> <span class="ot">:</span> <span class="dt">Either</span> (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="dt">String</span></code></pre></div>
<h1 id="enlarge-my-union">Enlarge my union!</h1>
<p>Can we do the opposite of <code>retract</code>? If I have a member of <code>Union [Nat, List String]</code>, can we claim that we have a member of a broader union?</p>
<p>Yes, we can <em>but</em> it is a bit more complex than the <code>retract</code> case. The main reason is that we have an infinity of target types for the result union.</p>
<h2 id="identifying-the-broader-unions">Identifying the broader unions</h2>
<p>The objective is to define a data type that contain a proof that an union is broader than another one. Or, by transitivity, that each element of a list of types is contained in another list. This is as simple as it sounds. I mean, really, if its sounds complicated to you, it will be complicated to read, if it sounds simple, it will be simple to read:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Sub</span> <span class="ot">:</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">SubZ</span> <span class="ot">:</span> <span class="dt">Sub</span> [] ys
  <span class="dt">SubK</span> <span class="ot">:</span> <span class="dt">Sub</span> xs ys <span class="ot">-&gt;</span>  <span class="dt">Elem</span> ty ys <span class="ot">-&gt;</span> <span class="dt">Sub</span> (ty<span class="ot">::</span>xs) ys</code></pre></div>
<p>To build a <code>Sub</code> type, we must be able proof that each element of the first list are in the second one.</p>
<h2 id="trying-to-generalize-union">Trying to <code>generalize</code> union</h2>
<p>Now that we have a definition of <code>Sub</code>, we can type our <code>generalize</code> function more easily:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">generalize</span> <span class="ot">:</span> (u<span class="ot">:</span> <span class="dt">Union</span> xs) <span class="ot">-&gt;</span> {<span class="kw">auto</span> s<span class="ot">:</span> <span class="dt">Sub</span> xs ys}
                           <span class="ot">-&gt;</span> <span class="dt">Union</span> ys</code></pre></div>
<p>Given an union, if we have a proof that the list of type in the union is a subset of the list of type in the resulting union, we can generalize the union. Yes, it’s that <strong>easy</strong>.</p>
<p>Things are getting more complex when we want to implement generalize. Let’s start with a naive implementation and see how it goes:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">generalize</span> <span class="ot">:</span> (u<span class="ot">:</span> <span class="dt">Union</span> xs) <span class="ot">-&gt;</span> {<span class="kw">auto</span> s<span class="ot">:</span> <span class="dt">Sub</span> xs ys}
                           <span class="ot">-&gt;</span> <span class="dt">Union</span> ys
generalize (<span class="dt">MemberHere</span> x) <span class="fu">=</span> member x
generalize (<span class="dt">MemberThere</span> x) {s <span class="fu">=</span> (<span class="dt">SubK</span> y z)} <span class="fu">=</span>
  generalize x {s<span class="fu">=</span>y}</code></pre></div>
<p>If we have at <code>MemberHere</code>, <code>x</code> is the value of the union, and thus, must be put in the result union, and we use previously defined <code>member</code> to do so. If we haven’t find the value yet, we just restart one step further.</p>
<p>This version reallly seemed ok to me. Unfortunately, it didn’t match the compiler expactations:</p>
<pre><code>When checking right hand side of generalize with expected type
        Union ys

When checking argument p to function Data.UnionType.member:
        Can&#39;t find a value of type
                Elem ty ys</code></pre>
<p>Almost there, the sole issue is that Idris wasn’t able to compute the new <em>location</em> of the value. Fortunately, this location is carried along by <code>Sub</code> and can be easily added:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">generalize</span> <span class="ot">:</span> (u<span class="ot">:</span> <span class="dt">Union</span> xs) <span class="ot">-&gt;</span> {<span class="kw">auto</span> s<span class="ot">:</span> <span class="dt">Sub</span> xs ys}
                           <span class="ot">-&gt;</span> <span class="dt">Union</span> ys
generalize (<span class="dt">MemberHere</span> x) {s <span class="fu">=</span> (<span class="dt">SubK</span> <span class="fu">_</span> z)} <span class="fu">=</span>
  member x {p <span class="fu">=</span> z}
generalize (<span class="dt">MemberThere</span> x) {s <span class="fu">=</span> (<span class="dt">SubK</span> y <span class="fu">_</span>)} <span class="fu">=</span>
  generalize x {s<span class="fu">=</span>y}</code></pre></div>
<p>And here we go:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;</span> <span class="ot">:</span><span class="kw">let</span> x <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="fu">$</span> member <span class="dv">2</span>
<span class="fu">&gt;</span> the (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="fu">$</span> generalize x
<span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> <span class="dv">2</span>) <span class="ot">:</span> <span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]</code></pre></div>
<h1 id="part-3-is-over">Part 3 is over</h1>
<p>That’s all for today.</p>
]]></description>
    <pubDate>Thu, 28 Jul 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-07-28-union-type-in-idris-part-3.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>
<item>
    <title>Union Type in Idris (Part 2)</title>
    <link>http://nicolas.biri.name//posts/2016-07-27-union-type-in-idris-part-2.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 27, 2016
    
        by Nicolas Biri
    
</div>

<p>The <a href="http://nicolas.biri.name/posts/2016-07-26-union-type-in-idris-part-1.html">first part</a>.</p>
<h1 id="first-part-summary">First part summary</h1>
<p>We have detailed how we can write union types in Idris and how to extract a value from it. We recall here the union type definition, that is used through this article:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Union</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">MemberHere</span> <span class="ot">:</span> ty <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>ts)
  <span class="dt">MemberThere</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>ts)</code></pre></div>
<p>You may also need the signature of the previously defined function for creating union type values and retrieving the value of an union:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">member</span> <span class="ot">:</span> ty <span class="ot">-&gt;</span> {<span class="kw">auto</span> e<span class="ot">:</span> <span class="dt">Elem</span> ty ts} <span class="ot">-&gt;</span> <span class="dt">Union</span> ts
<span class="fu">get</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> {<span class="kw">auto</span> p<span class="ot">:</span> <span class="dt">Elem</span> ty ts} <span class="ot">-&gt;</span> <span class="dt">Maybe</span> ty</code></pre></div>
<h1 id="folding-union">Folding Union</h1>
<p>When I started reading some Idris, I was amazed by the <a href="https://gist.github.com/puffnfresh/11202637"><code>printf</code> example</a> (also available <a href="https://www.youtube.com/watch?v=fVBck2Zngjo">in video</a>).</p>
<p>And my motivation when I start union type was actually to provide a type safe way to fold an union type.</p>
<h2 id="a-first-try-decomposing-the-union-type">A first try: Decomposing the union type</h2>
<p>So my first idea was to decompose the union to know which functions we need to cover all the cases.. It means that I wanted something like:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;</span> <span class="ot">:</span>t foldUnion (the (<span class="dt">Union</span> [<span class="dt">Char</span>, <span class="dt">String</span>]) <span class="fu">$</span> member <span class="ch">&#39;c&#39;</span>)
foldUnion (the (<span class="dt">Union</span> [<span class="dt">Char</span>, <span class="dt">String</span>]) <span class="fu">$</span> member <span class="ch">&#39;c&#39;</span>) <span class="ot">:</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</code></pre></div>
<p>if you want to do such a thing, it means that the type of <code>foldUnion u</code> where <code>u</code> is an arbitrary union will <em>depend</em> on the type of <code>u</code>. So it means that our code will be like:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">foldUnion</span> <span class="ot">:</span> (u<span class="ot">:</span> <span class="dt">Union</span> ts) <span class="ot">-&gt;</span> <span class="dt">UnionFold</span> ts</code></pre></div>
<p>Where <code>UnionFold</code> should build a type from a list of type.</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">UnionFold</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code></pre></div>
<p>The case decoposition is quite straightforward atually. If the list is empty, we are done, so the type should be an arbitrary <code>a</code>. If there is a type in the list, we should provide a function for this type and continue with the tail of the list:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">UnionFold</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>
<span class="dt">UnionFold</span> [] <span class="fu">=</span> a
<span class="dt">UnionFold</span> (ty<span class="ot">:</span>ts) <span class="fu">=</span> (ty <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">UnionFold</span> ts</code></pre></div>
<p>Let’s come back to <code>foldUnion</code>. The next issue we face is once again is to choose the right function to apply:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">foldUnion</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> <span class="dt">UnionCata</span> a ts
foldUnion (<span class="dt">MemberHere</span> x) <span class="fu">=</span> <span class="fu">\</span>f <span class="ot">=&gt;</span> foldUnion&#39; (f x)
  <span class="kw">where</span>
    <span class="fu">foldUnion&#39;</span> <span class="ot">:</span> {xs <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> (x <span class="ot">:</span> a) <span class="ot">-&gt;</span> <span class="dt">UnionCata</span> a xs
    foldUnion&#39; {xs <span class="fu">=</span> []} x <span class="fu">=</span> x
    foldUnion&#39; {xs <span class="fu">=</span> <span class="fu">_</span><span class="ot">::</span>xs&#39;} x <span class="fu">=</span> const <span class="fu">$</span> foldUnion&#39; {xs<span class="fu">=</span>xs&#39;} x
foldUnion (<span class="dt">MemberThere</span> later) <span class="fu">=</span> const <span class="fu">$</span> foldUnion later</code></pre></div>
<p>If we have the <code>MemberHere</code> constructor, it means thas the element of the union has the first type of the union, and thus, we need to apply the first function. The challenge is then to skip all the other functions until we exhaust all the mapping functions.</p>
<p>If we are in the <code>MemberThere</code> case, we must skip the next function and look further.</p>
<p>We can know write things like:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;&gt;&gt;</span> <span class="ot">:</span><span class="kw">let</span> x <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="fu">$</span> member <span class="st">&quot;Ahoy!&quot;</span>
<span class="fu">&gt;&gt;&gt;</span> foldUnion x length id (sum <span class="fu">.</span> map length)
<span class="dv">5</span> <span class="ot">:</span> <span class="dt">Nat</span></code></pre></div>
<h2 id="functions-to-the-left-union-to-the-right">Functions to the left, union to the right</h2>
<p>There is an issue with the former proposal: we need to provide the unon first. It makes sense in the case of <code>printf</code>, as we want to provide the format string before its parameter. It’s less meaningful in the case of folding.</p>
<p>It’s pretty hard to change the parameter order though. Actually, if we dont know the union, how can we know if we still have to pass a function or the final union. More clearly, we aren’t able to define the type of a partially applied function.</p>
<p>An alternative is to gather the folding functions to define what kind of unions can be fold with these functions.</p>
<p>The objective is consequently to obtain a signature like:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">foldUnion</span> <span class="ot">:</span> <span class="dt">UnionFold</span> a ts <span class="ot">-&gt;</span> (u<span class="ot">:</span> <span class="dt">Union</span> ts) <span class="ot">-&gt;</span> a</code></pre></div>
<p>With this signature, <code>UnionFold a ts</code> indicates that we have sufficient functions to fold an <code>Union ts</code>, to provide an <code>a</code>. My goal was to be able to build this UnionFold as easily as possible. I take advantage of the <a href="http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#list-and-vect">list syntax in Idris</a> to obtain a convenient way to define it. So <code>UnionFold a ts</code> is defined as:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">UnionFold</span> <span class="ot">:</span> (target<span class="ot">:</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (union<span class="ot">:</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">Nil</span> <span class="ot">:</span> <span class="dt">UnionFold</span> a (<span class="dt">Union</span> [])
  <span class="fu">(::)</span> <span class="ot">:</span> (t <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">UnionFold</span> a (<span class="dt">Union</span> ts)
                  <span class="ot">-&gt;</span> <span class="dt">UnionFold</span> a (<span class="dt">Union</span> (t<span class="ot">::</span>ts))</code></pre></div>
<p>This definition is straightforward as soon as we have understand the objective of this type.</p>
<p>With this, we can know detail <code>foldUnion</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">foldUnion</span> <span class="ot">:</span> (fs<span class="ot">:</span> <span class="dt">UnionFold</span> a (<span class="dt">Union</span> ts)) <span class="ot">-&gt;</span> <span class="dt">Union</span> ts
                                         <span class="ot">-&gt;</span> a
foldUnion [] (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="kw">impossible</span>
foldUnion [] (<span class="dt">MemberThere</span> <span class="fu">_</span>) <span class="kw">impossible</span>
foldUnion (f <span class="ot">::</span> <span class="fu">_</span>) (<span class="dt">MemberHere</span> y) <span class="fu">=</span> f y
foldUnion (f <span class="ot">::</span> xs) (<span class="dt">MemberThere</span> y) <span class="fu">=</span> foldUnion xs y</code></pre></div>
<p>The two first cases (ithe impossible ones) can be omited (as they are impossible). I added them for documentation purpose. The two last cases are quite easy to read: we go through the <code>UnionFold</code> and the <code>Union</code> simultaneously and as soon as we fan the right location, we apply the corresponding function.</p>
<p>And the previous example became:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;&gt;&gt;</span> <span class="ot">:</span><span class="kw">let</span> x <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="fu">$</span> member <span class="st">&quot;Ahoy!&quot;</span>
<span class="fu">&gt;&gt;&gt;</span> foldUnion [length, id, sum <span class="fu">.</span> map length] x
<span class="dv">5</span> <span class="ot">:</span> <span class="dt">Nat</span></code></pre></div>
<h1 id="part-2-is-over">Part 2 is over</h1>
<p>That’s all for today, next time I will talk about union <a href="http://nicolas.biri.name/posts/2016-07-28-union-type-in-idris-part-3.html">restriction and generalization</a>.</p>
]]></description>
    <pubDate>Wed, 27 Jul 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-07-27-union-type-in-idris-part-2.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>

    </channel>
</rss>
