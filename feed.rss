<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Codice and Circenses</title>
        <link>http://nicolas.biri.name/</link>
        <description><![CDATA[IT, Programming, boardgames and random thoughts]]></description>
        <atom:link href="http://nicolas.biri.name//feed.rss" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Tue, 02 Aug 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Union Type in Idris (Part 4)</title>
    <link>http://nicolas.biri.name//posts/2016-08-02-union-type-in-idris-part-4.html</link>
    <description><![CDATA[<div class="info">
    Posted on August  2, 2016
    
        by Nicolas Biri
    
</div>

<p>Go back to the <a href="http://nicolas.biri.name/posts/2016-07-26-union-type-in-idris-part-1.html">first part</a>.</p>
<h1 id="a-glimpe-of-equality">A glimpe of equality</h1>
<p>Idris handles equality with a typeclass, just like Haskell. Whilst equality must be define specifically for each sum type, we can define the equality in a generic manner for union types. The idea is to define the equality iteratively on the list of types of the union.</p>
<h2 id="equality-for-union-xxs">Equality for <code>Union x:xs</code></h2>
<p>Let’s start with the recursive case, do we really need to elaborate?</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">(<span class="dt">Eq</span> ty, <span class="dt">Eq</span> (<span class="dt">Union</span> xs)) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Union</span> (ty<span class="ot">::</span>xs)) <span class="kw">where</span>
  (<span class="fu">==</span>) (<span class="dt">MemberHere</span> x) (<span class="dt">MemberHere</span> y) <span class="fu">=</span> x <span class="fu">==</span> y
  (<span class="fu">==</span>) (<span class="dt">MemberHere</span> x) (<span class="dt">MemberThere</span> y) <span class="fu">=</span> <span class="dt">False</span>
  (<span class="fu">==</span>) (<span class="dt">MemberThere</span> x) (<span class="dt">MemberHere</span> y) <span class="fu">=</span> <span class="dt">False</span>
  (<span class="fu">==</span>) (<span class="dt">MemberThere</span> x) (<span class="dt">MemberThere</span> y) <span class="fu">=</span> x <span class="fu">==</span> y</code></pre></div>
<p>We need equality for the previous union (induction) nd for the newly added type. Then, two terms are equal if they point to the same type and have the same value.</p>
<h2 id="the-base-case">The base case</h2>
<p>Things here are a little trickier. We nned an instance of <code>Eq (Union [])</code>. Let’s look back at the <code>Union</code> definition:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Union</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">MemberHere</span> <span class="ot">:</span> (x<span class="ot">:</span> ty) <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>xs)
  <span class="dt">MemberThere</span> <span class="ot">:</span> (x<span class="ot">:</span> <span class="dt">Union</span> xs) <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>xs)</code></pre></div>
<p>Do you see the potential issue? None of them allow us to build a <code>Union []</code>. It’s impossible to build an element of <code>Union []</code>? Just explain it to Idris:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Eq</span> (<span class="dt">Union</span> []) <span class="kw">where</span>
  (<span class="fu">==</span>) (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="fu">_</span> <span class="kw">impossible</span>
  (<span class="fu">/=</span>) (<span class="dt">MemberThere</span> <span class="fu">_</span>) <span class="fu">_</span> <span class="kw">impossible</span></code></pre></div>
<p>Profit:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;foo&quot;</span> <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;foo&quot;</span>
<span class="dt">True</span> <span class="ot">:</span> <span class="dt">Boolean</span>
<span class="fu">&gt;</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;foo&quot;</span> <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;bar&quot;</span>
<span class="dt">False</span> <span class="ot">:</span> <span class="dt">Boolean</span>
<span class="fu">&gt;</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;foo&quot;</span> <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="dv">42</span>
<span class="dt">False</span> <span class="ot">:</span> <span class="dt">Boolean</span></code></pre></div>
<h2 id="uninhabited-types">Uninhabited types</h2>
<p>There is an alternative to the <code>impossible</code> solution. We can claim that a type is uninhabited thanks to a typeclass:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Uninhabited</span> (<span class="dt">Union</span> []) <span class="kw">where</span>
    uninhabited (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="kw">impossible</span>
    uninhabited (<span class="dt">MemberThere</span> <span class="fu">_</span>) <span class="kw">impossible</span></code></pre></div>
<p><code>Uninhabited</code> comes with an <code>absurd</code> funciton of type <code>Uninhabited e =&gt; e -&gt; a</code> absurd can be read as: if we have an instance of an uninhabited type, we can build anything from it.</p>
<p>Thanks to <code>Uninhabited</code>, our instance of <code>Eq</code> can be written:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Eq</span> (<span class="dt">Union</span> []) <span class="kw">where</span>
  (<span class="fu">==</span>) x <span class="fu">_</span> <span class="fu">=</span> absurd x</code></pre></div>
<h1 id="unions-and-synonyms">Unions and synonyms</h1>
<p>If our unions are well defined, a union of a unique type should be isomorphic to this type. A union of two types should be isomorphic to <code>Either</code>. Let’s transform these assumptions into proofs.</p>
<h2 id="morphisms">Morphisms</h2>
<p>The morphisms can be implemented as instances of the <code>Cast</code> typeclass and are straightforward as soon as we know how to deal with uninhabited types:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Cast</span> (<span class="dt">Union</span> [ty]) ty <span class="kw">where</span>
  cast (<span class="dt">MemberHere</span> x) <span class="fu">=</span> x
  cast (<span class="dt">MemberThere</span> x) <span class="fu">=</span> absurd x

<span class="dt">Cast</span> l (<span class="dt">Union</span> [l]) <span class="kw">where</span>
  cast x <span class="fu">=</span> (<span class="dt">MemberHere</span> x)

<span class="dt">Cast</span> (<span class="dt">Union</span> [l, r]) (<span class="dt">Either</span> l r) <span class="kw">where</span>
  cast (<span class="dt">MemberHere</span> x) <span class="fu">=</span> <span class="dt">Left</span> x
  cast (<span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> x)) <span class="fu">=</span> <span class="dt">Right</span> x
  cast (<span class="dt">MemberThere</span> (<span class="dt">MemberThere</span> x)) <span class="fu">=</span> absurd x

<span class="dt">Cast</span> (<span class="dt">Either</span> l r) (<span class="dt">Union</span> [l, r]) <span class="kw">where</span>
  cast (<span class="dt">Left</span> x) <span class="fu">=</span> (<span class="dt">MemberHere</span> x)
  cast (<span class="dt">Right</span> x) <span class="fu">=</span> (<span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> x))</code></pre></div>
<h2 id="put-an-iso-in-our-morphisms">Put an iso in our morphisms</h2>
<p>Idris has a <code>Iso</code> type, that is use to prove that two types are isomorphic. Here is its definition:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Iso</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>
  <span class="dt">MkIso</span> <span class="ot">:</span> (to <span class="ot">:</span> a <span class="ot">-&gt;</span> b)
        <span class="ot">-&gt;</span> (from <span class="ot">:</span> b <span class="ot">-&gt;</span> a)
        <span class="ot">-&gt;</span> (toFrom <span class="ot">:</span> (y <span class="ot">:</span> b) <span class="ot">-&gt;</span> to (from y) <span class="fu">=</span> y)
        <span class="ot">-&gt;</span> (fromTo <span class="ot">:</span> (x <span class="ot">:</span> a) <span class="ot">-&gt;</span> from (to x) <span class="fu">=</span> x)
        <span class="ot">-&gt;</span> <span class="dt">Iso</span> a b</code></pre></div>
<p><code>to</code> and <code>from</code> are the two morphisms used to build the isomorphism. <code>toFrom</code> and <code>fromTo</code> are proofs. They are populated if and only if for (<code>to . from</code>) and (<code>from . to</code>) behave like the <code>id</code> function.</p>
<p>Thus, being able to build an instance of <code>Iso a b</code> is a proof that <code>a</code> and <code>b</code> are isomorphic. Let’s buils these instances for <code>Union</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">oneTypeUnion</span> <span class="ot">:</span> <span class="dt">Iso</span> (<span class="dt">Union</span> [ty]) ty
oneTypeUnion <span class="fu">=</span> <span class="dt">MkIso</span> cast cast toFrom fromTo
  <span class="kw">where</span>
    toFrom <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberThere</span> x) <span class="fu">=</span> absurd x</code></pre></div>
<p>And:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">eitherUnion</span> <span class="ot">:</span> <span class="dt">Iso</span> (<span class="dt">Union</span> [l, r]) (<span class="dt">Either</span> l r)
eitherUnion <span class="fu">=</span> <span class="dt">MkIso</span> cast cast toFrom fromTo
  <span class="kw">where</span>
    toFrom (<span class="dt">Left</span> <span class="fu">_</span>) <span class="fu">=</span> <span class="dt">Refl</span>
    toFrom (<span class="dt">Right</span> <span class="fu">_</span>) <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> <span class="fu">_</span>)) <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberThere</span> (<span class="dt">MemberThere</span> x)) <span class="fu">=</span> absurd x</code></pre></div>
<p><code>Refl</code> is a member of the type <code>x = x</code>. Being able to compile this code build a formal proof of the existence of the isomorphisms.</p>
<h1 id="part-4-is-over">Part 4 is over</h1>
<p>That’s all for this serie, the code is <a href="https://github.com/berewt/UnionType">on github</a>.</p>
]]></description>
    <pubDate>Tue, 02 Aug 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-08-02-union-type-in-idris-part-4.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>
<item>
    <title>Union Type in Idris (Part 3)</title>
    <link>http://nicolas.biri.name//posts/2016-07-28-union-type-in-idris-part-3.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 28, 2016
    
        by Nicolas Biri
    
</div>

<p>Go back to the <a href="http://nicolas.biri.name/posts/2016-07-26-union-type-in-idris-part-1.html">first part</a>.</p>
<h1 id="some-are-better-than-others-union-is-better-than-sum">Some are better than others, Union is better than sum</h1>
<p>At this point, we have a slightly less complex syntax than sum types (with some drawbacks, but I will detail them in another part), but did we have other benefits?</p>
<p>Well, yes.</p>
<p>Today, we are going to inverstigate how flexible union types are. More precisely, I will detail union type restrictions and generalisation.</p>
<h1 id="shrink-my-union">Shrink my union</h1>
<p>Let suppose that we have a variable <code>x</code> of type <code>Union [Nat, String, List String]</code> and the following repl session:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;</span> the (<span class="dt">Maybe</span> <span class="dt">Nat</span>) x
<span class="dt">Nothing</span> <span class="ot">:</span> <span class="dt">Maybe</span> <span class="dt">Nat</span></code></pre></div>
<p>We know that <code>x</code> does not contain a <code>Nat</code>. Thus, <code>x</code> contains either a <code>String</code> or a <code>List String</code>. Well, we can explicitly express it with union types.</p>
<p>Let’s compute the type of this reasoning. Given an union instance, we can either get a value of a type in this uion or we can restrict the union. Quite clear and easy to write:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">retract</span> <span class="ot">:</span> <span class="dt">Union</span> xs <span class="ot">-&gt;</span> {<span class="kw">auto</span> p<span class="ot">:</span> <span class="dt">Elem</span> ty xs}
                   <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Union</span> (dropElem xs p)) ty</code></pre></div>
<p>The result type may require some explanations. The presence of <code>Either</code> and the right case (<code>ty</code>) is clear. The left case (<code>dropElem xs p</code>) is straightforward if we look at the <a href="http://www.idris-lang.org/docs/current/base_doc/docs/Data.List.html#Data.List.dropElem"><code>dropElem</code> documentation</a>: it removes the element pointed by <code>p</code> from the list.</p>
<p>The implementation is almost as easy to write as the type:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">retract</span> <span class="ot">:</span> <span class="dt">Union</span> xs <span class="ot">-&gt;</span> {<span class="kw">auto</span> p<span class="ot">:</span> <span class="dt">Elem</span> ty xs}
                  <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Union</span> (dropElem xs p)) ty
retract (<span class="dt">MemberHere</span> x) {p <span class="fu">=</span> <span class="dt">Here</span>} <span class="fu">=</span> <span class="dt">Right</span> x
retract (<span class="dt">MemberHere</span> x) {p <span class="fu">=</span> (<span class="dt">There</span> <span class="fu">_</span>)} <span class="fu">=</span>
  <span class="dt">Left</span> (<span class="dt">MemberHere</span> x)
retract (<span class="dt">MemberThere</span> x) {p <span class="fu">=</span> <span class="dt">Here</span>} <span class="fu">=</span>
  <span class="dt">Left</span> x
retract (<span class="dt">MemberThere</span> x) {p <span class="fu">=</span> (<span class="dt">There</span> later)} <span class="fu">=</span>
  either (<span class="dt">Left</span> <span class="fu">.</span> <span class="dt">MemberThere</span>)
         <span class="dt">Right</span>
         <span class="fu">$</span> retract x {p <span class="fu">=</span> later}</code></pre></div>
<p>The 3 first cases are trivial, they can almost be completed automatically by Idris (I should talk about this really cool feature in a next post). The last case is a bit more complex. The idea is to <em>lift</em> the result of retract to the next step: on a right, propagate the found value, on a left, just buried it one step further.</p>
<p>It’s time to see retract in action:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;</span> <span class="ot">:</span><span class="kw">let</span> x <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="fu">$</span> member <span class="st">&quot;foo&quot;</span>
<span class="fu">&gt;</span> the (<span class="dt">Either</span> <span class="fu">_</span> <span class="dt">Nat</span>) <span class="fu">$</span> retract x
<span class="dt">Left</span> (<span class="dt">MemberHere</span> <span class="st">&quot;foo&quot;</span>) <span class="ot">:</span> <span class="dt">Either</span> (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="dt">Nat</span>
<span class="fu">&gt;</span> the (<span class="dt">Either</span> <span class="fu">_</span> <span class="dt">String</span>) <span class="fu">$</span> retract x
<span class="dt">Right</span> <span class="st">&quot;foo&quot;</span> <span class="ot">:</span> <span class="dt">Either</span> (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="dt">String</span></code></pre></div>
<h1 id="enlarge-my-union">Enlarge my union!</h1>
<p>Can we do the opposite of <code>retract</code>? If I have a member of <code>Union [Nat, List String]</code>, can we claim that we have a member of a broader union?</p>
<p>Yes, we can <em>but</em> it is a bit more complex than the <code>retract</code> case. The main reason is that we have an infinity of target types for the result union.</p>
<h2 id="identifying-the-broader-unions">Identifying the broader unions</h2>
<p>The objective is to define a data type that contain a proof that an union is broader than another one. Or, by transitivity, that each element of a list of types is contained in another list. This is as simple as it sounds. I mean, really, if its sounds complicated to you, it will be complicated to read, if it sounds simple, it will be simple to read:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Sub</span> <span class="ot">:</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">SubZ</span> <span class="ot">:</span> <span class="dt">Sub</span> [] ys
  <span class="dt">SubK</span> <span class="ot">:</span> <span class="dt">Sub</span> xs ys <span class="ot">-&gt;</span>  <span class="dt">Elem</span> ty ys <span class="ot">-&gt;</span> <span class="dt">Sub</span> (ty<span class="ot">::</span>xs) ys</code></pre></div>
<p>To build a <code>Sub</code> type, we must be able proof that each element of the first list are in the second one.</p>
<h2 id="trying-to-generalize-union">Trying to <code>generalize</code> union</h2>
<p>Now that we have a definition of <code>Sub</code>, we can type our <code>generalize</code> function more easily:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">generalize</span> <span class="ot">:</span> (u<span class="ot">:</span> <span class="dt">Union</span> xs) <span class="ot">-&gt;</span> {<span class="kw">auto</span> s<span class="ot">:</span> <span class="dt">Sub</span> xs ys}
                           <span class="ot">-&gt;</span> <span class="dt">Union</span> ys</code></pre></div>
<p>Given an union, if we have a proof that the list of type in the union is a subset of the list of type in the resulting union, we can generalize the union. Yes, it’s that <strong>easy</strong>.</p>
<p>Things are getting more complex when we want to implement generalize. Let’s start with a naive implementation and see how it goes:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">generalize</span> <span class="ot">:</span> (u<span class="ot">:</span> <span class="dt">Union</span> xs) <span class="ot">-&gt;</span> {<span class="kw">auto</span> s<span class="ot">:</span> <span class="dt">Sub</span> xs ys}
                           <span class="ot">-&gt;</span> <span class="dt">Union</span> ys
generalize (<span class="dt">MemberHere</span> x) <span class="fu">=</span> member x
generalize (<span class="dt">MemberThere</span> x) {s <span class="fu">=</span> (<span class="dt">SubK</span> y z)} <span class="fu">=</span>
  generalize x {s<span class="fu">=</span>y}</code></pre></div>
<p>If we have at <code>MemberHere</code>, <code>x</code> is the value of the union, and thus, must be put in the result union, and we use previously defined <code>member</code> to do so. If we haven’t find the value yet, we just restart one step further.</p>
<p>This version reallly seemed ok to me. Unfortunately, it didn’t match the compiler expactations:</p>
<pre><code>When checking right hand side of generalize with expected type
        Union ys

When checking argument p to function Data.UnionType.member:
        Can&#39;t find a value of type
                Elem ty ys</code></pre>
<p>Almost there, the sole issue is that Idris wasn’t able to compute the new <em>location</em> of the value. Fortunately, this location is carried along by <code>Sub</code> and can be easily added:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">generalize</span> <span class="ot">:</span> (u<span class="ot">:</span> <span class="dt">Union</span> xs) <span class="ot">-&gt;</span> {<span class="kw">auto</span> s<span class="ot">:</span> <span class="dt">Sub</span> xs ys}
                           <span class="ot">-&gt;</span> <span class="dt">Union</span> ys
generalize (<span class="dt">MemberHere</span> x) {s <span class="fu">=</span> (<span class="dt">SubK</span> <span class="fu">_</span> z)} <span class="fu">=</span>
  member x {p <span class="fu">=</span> z}
generalize (<span class="dt">MemberThere</span> x) {s <span class="fu">=</span> (<span class="dt">SubK</span> y <span class="fu">_</span>)} <span class="fu">=</span>
  generalize x {s<span class="fu">=</span>y}</code></pre></div>
<p>And here we go:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;</span> <span class="ot">:</span><span class="kw">let</span> x <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="fu">$</span> member <span class="dv">2</span>
<span class="fu">&gt;</span> the (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="fu">$</span> generalize x
<span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> <span class="dv">2</span>) <span class="ot">:</span> <span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]</code></pre></div>
<h1 id="part-3-is-over">Part 3 is over</h1>
<p>That’s all for today.</p>
]]></description>
    <pubDate>Thu, 28 Jul 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-07-28-union-type-in-idris-part-3.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>
<item>
    <title>Union Type in Idris (Part 2)</title>
    <link>http://nicolas.biri.name//posts/2016-07-27-union-type-in-idris-part-2.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 27, 2016
    
        by Nicolas Biri
    
</div>

<p>The <a href="http://nicolas.biri.name/posts/2016-07-26-union-type-in-idris-part-1.html">first part</a>.</p>
<h1 id="first-part-summary">First part summary</h1>
<p>We have detailed how we can write union types in Idris and how to extract a value from it. We recall here the union type definition, that is used through this article:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Union</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">MemberHere</span> <span class="ot">:</span> ty <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>ts)
  <span class="dt">MemberThere</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>ts)</code></pre></div>
<p>You may also need the signature of the previously defined function for creating union type values and retrieving the value of an union:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">member</span> <span class="ot">:</span> ty <span class="ot">-&gt;</span> {<span class="kw">auto</span> e<span class="ot">:</span> <span class="dt">Elem</span> ty ts} <span class="ot">-&gt;</span> <span class="dt">Union</span> ts
<span class="fu">get</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> {<span class="kw">auto</span> p<span class="ot">:</span> <span class="dt">Elem</span> ty ts} <span class="ot">-&gt;</span> <span class="dt">Maybe</span> ty</code></pre></div>
<h1 id="folding-union">Folding Union</h1>
<p>When I started reading some Idris, I was amazed by the <a href="https://gist.github.com/puffnfresh/11202637"><code>printf</code> example</a> (also available <a href="https://www.youtube.com/watch?v=fVBck2Zngjo">in video</a>).</p>
<p>And my motivation when I start union type was actually to provide a type safe way to fold an union type.</p>
<h2 id="a-first-try-decomposing-the-union-type">A first try: Decomposing the union type</h2>
<p>So my first idea was to decompose the union to know which functions we need to cover all the cases.. It means that I wanted something like:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;</span> <span class="ot">:</span>t foldUnion (the (<span class="dt">Union</span> [<span class="dt">Char</span>, <span class="dt">String</span>]) <span class="fu">$</span> member <span class="ch">&#39;c&#39;</span>)
foldUnion (the (<span class="dt">Union</span> [<span class="dt">Char</span>, <span class="dt">String</span>]) <span class="fu">$</span> member <span class="ch">&#39;c&#39;</span>) <span class="ot">:</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</code></pre></div>
<p>if you want to do such a thing, it means that the type of <code>foldUnion u</code> where <code>u</code> is an arbitrary union will <em>depend</em> on the type of <code>u</code>. So it means that our code will be like:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">foldUnion</span> <span class="ot">:</span> (u<span class="ot">:</span> <span class="dt">Union</span> ts) <span class="ot">-&gt;</span> <span class="dt">UnionFold</span> ts</code></pre></div>
<p>Where <code>UnionFold</code> should build a type from a list of type.</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">UnionFold</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code></pre></div>
<p>The case decoposition is quite straightforward atually. If the list is empty, we are done, so the type should be an arbitrary <code>a</code>. If there is a type in the list, we should provide a function for this type and continue with the tail of the list:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">UnionFold</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>
<span class="dt">UnionFold</span> [] <span class="fu">=</span> a
<span class="dt">UnionFold</span> (ty<span class="ot">:</span>ts) <span class="fu">=</span> (ty <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">UnionFold</span> ts</code></pre></div>
<p>Let’s come back to <code>foldUnion</code>. The next issue we face is once again is to choose the right function to apply:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">foldUnion</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> <span class="dt">UnionCata</span> a ts
foldUnion (<span class="dt">MemberHere</span> x) <span class="fu">=</span> <span class="fu">\</span>f <span class="ot">=&gt;</span> foldUnion&#39; (f x)
  <span class="kw">where</span>
    <span class="fu">foldUnion&#39;</span> <span class="ot">:</span> {xs <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> (x <span class="ot">:</span> a) <span class="ot">-&gt;</span> <span class="dt">UnionCata</span> a xs
    foldUnion&#39; {xs <span class="fu">=</span> []} x <span class="fu">=</span> x
    foldUnion&#39; {xs <span class="fu">=</span> <span class="fu">_</span><span class="ot">::</span>xs&#39;} x <span class="fu">=</span> const <span class="fu">$</span> foldUnion&#39; {xs<span class="fu">=</span>xs&#39;} x
foldUnion (<span class="dt">MemberThere</span> later) <span class="fu">=</span> const <span class="fu">$</span> foldUnion later</code></pre></div>
<p>If we have the <code>MemberHere</code> constructor, it means thas the element of the union has the first type of the union, and thus, we need to apply the first function. The challenge is then to skip all the other functions until we exhaust all the mapping functions.</p>
<p>If we are in the <code>MemberThere</code> case, we must skip the next function and look further.</p>
<p>We can know write things like:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;&gt;&gt;</span> <span class="ot">:</span><span class="kw">let</span> x <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="fu">$</span> member <span class="st">&quot;Ahoy!&quot;</span>
<span class="fu">&gt;&gt;&gt;</span> foldUnion x length id (sum <span class="fu">.</span> map length)
<span class="dv">5</span> <span class="ot">:</span> <span class="dt">Nat</span></code></pre></div>
<h2 id="functions-to-the-left-union-to-the-right">Functions to the left, union to the right</h2>
<p>There is an issue with the former proposal: we need to provide the unon first. It makes sense in the case of <code>printf</code>, as we want to provide the format string before its parameter. It’s less meaningful in the case of folding.</p>
<p>It’s pretty hard to change the parameter order though. Actually, if we dont know the union, how can we know if we still have to pass a function or the final union. More clearly, we aren’t able to define the type of a partially applied function.</p>
<p>An alternative is to gather the folding functions to define what kind of unions can be fold with these functions.</p>
<p>The objective is consequently to obtain a signature like:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">foldUnion</span> <span class="ot">:</span> <span class="dt">UnionFold</span> a ts <span class="ot">-&gt;</span> (u<span class="ot">:</span> <span class="dt">Union</span> ts) <span class="ot">-&gt;</span> a</code></pre></div>
<p>With this signature, <code>UnionFold a ts</code> indicates that we have sufficient functions to fold an <code>Union ts</code>, to provide an <code>a</code>. My goal was to be able to build this UnionFold as easily as possible. I take advantage of the <a href="http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#list-and-vect">list syntax in Idris</a> to obtain a convenient way to define it. So <code>UnionFold a ts</code> is defined as:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">UnionFold</span> <span class="ot">:</span> (target<span class="ot">:</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> (union<span class="ot">:</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">Nil</span> <span class="ot">:</span> <span class="dt">UnionFold</span> a (<span class="dt">Union</span> [])
  <span class="fu">(::)</span> <span class="ot">:</span> (t <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">UnionFold</span> a (<span class="dt">Union</span> ts)
                  <span class="ot">-&gt;</span> <span class="dt">UnionFold</span> a (<span class="dt">Union</span> (t<span class="ot">::</span>ts))</code></pre></div>
<p>This definition is straightforward as soon as we have understand the objective of this type.</p>
<p>With this, we can know detail <code>foldUnion</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">foldUnion</span> <span class="ot">:</span> (fs<span class="ot">:</span> <span class="dt">UnionFold</span> a (<span class="dt">Union</span> ts)) <span class="ot">-&gt;</span> <span class="dt">Union</span> ts
                                         <span class="ot">-&gt;</span> a
foldUnion [] (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="kw">impossible</span>
foldUnion [] (<span class="dt">MemberThere</span> <span class="fu">_</span>) <span class="kw">impossible</span>
foldUnion (f <span class="ot">::</span> <span class="fu">_</span>) (<span class="dt">MemberHere</span> y) <span class="fu">=</span> f y
foldUnion (f <span class="ot">::</span> xs) (<span class="dt">MemberThere</span> y) <span class="fu">=</span> foldUnion xs y</code></pre></div>
<p>The two first cases (ithe impossible ones) can be omited (as they are impossible). I added them for documentation purpose. The two last cases are quite easy to read: we go through the <code>UnionFold</code> and the <code>Union</code> simultaneously and as soon as we fan the right location, we apply the corresponding function.</p>
<p>And the previous example became:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;&gt;&gt;</span> <span class="ot">:</span><span class="kw">let</span> x <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="fu">$</span> member <span class="st">&quot;Ahoy!&quot;</span>
<span class="fu">&gt;&gt;&gt;</span> foldUnion [length, id, sum <span class="fu">.</span> map length] x
<span class="dv">5</span> <span class="ot">:</span> <span class="dt">Nat</span></code></pre></div>
<h1 id="part-2-is-over">Part 2 is over</h1>
<p>That’s all for today, next time I will talk about union <a href="http://nicolas.biri.name/posts/2016-07-28-union-type-in-idris-part-3.html">restriction and generalization</a>.</p>
]]></description>
    <pubDate>Wed, 27 Jul 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-07-27-union-type-in-idris-part-2.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>
<item>
    <title>Union Type in Idris (Part 1)</title>
    <link>http://nicolas.biri.name//posts/2016-07-26-union-type-in-idris-part-1.html</link>
    <description><![CDATA[<div class="info">
    Posted on July 26, 2016
    
        by Nicolas Biri
    
</div>

<p><strong>TL;DR:</strong> This article discusses the interest of union types and presents an implementation of this concept in Idris.</p>
<h1 id="an-introduction-to-sum-and-union-types">An introduction to sum and union types</h1>
<p>If you are familiar with language like Haskell or Scala, you may know what a sum type is. Consider the following example in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Whisky</span> <span class="fu">=</span> <span class="dt">Whisky</span> {<span class="ot">age ::</span> <span class="dt">Nat</span>,<span class="ot"> alcohol ::</span> <span class="dt">Float</span>}
<span class="kw">data</span> <span class="dt">Beer</span> <span class="fu">=</span> <span class="dt">Beer</span> {<span class="ot">alcohol ::</span> <span class="dt">Float</span>}

<span class="kw">data</span> <span class="dt">Alcohol</span> <span class="fu">=</span> <span class="dt">AlcoholWhisky</span> <span class="dt">Whisky</span>
             <span class="fu">|</span> <span class="dt">AlcoholBeer</span> <span class="dt">Beer</span>

<span class="ot">myAlcohol ::</span> <span class="dt">Alcohol</span>
myAlcohol <span class="fu">=</span> <span class="dt">AlcoholWhisky</span> (<span class="dt">Whisky</span> <span class="dv">12</span> <span class="dv">40</span>)</code></pre></div>
<p>In this short example, <code>Alcohol</code> is a sum type. It’s called like this because the number of inhabitants of this type is the sum of the inhabitants of the type <code>Whisky</code> and of those of the type <code>Beer</code>.</p>
<p>I always thought that the need of the <code>Alcohol</code> constructors (<code>AlcoholWhisky</code> and <code>AlcoholBeer</code>) is a little clumpsy in such types. It’s getting worse when we stack sums:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Water</span> <span class="fu">=</span> <span class="dt">Water</span> {<span class="ot">calcium ::</span> <span class="dt">Float</span>}
<span class="kw">data</span> <span class="dt">OrangeJuice</span> <span class="fu">=</span> <span class="dt">Water</span> {<span class="ot">sugar ::</span> <span class="dt">Float</span>}

<span class="kw">data</span> <span class="dt">NoAlcohol</span> <span class="fu">=</span> <span class="dt">NoAlcoholWater</span> <span class="dt">Water</span>
               <span class="fu">|</span> <span class="dt">NoAlcoholOrangeJuice</span> <span class="dt">OrangeJuice</span>

<span class="kw">data</span> <span class="dt">Beverage</span> <span class="fu">=</span> <span class="dt">BeverageAlcohol</span> <span class="dt">Alcohol</span>
              <span class="fu">|</span> <span class="dt">BeverageNoAlcohol</span> <span class="dt">NoAlcohol</span>

<span class="ot">myBeverage ::</span> <span class="dt">Beverage</span>
myBeverage <span class="fu">=</span> <span class="dt">BeverageAlcohol</span> myAlcohol</code></pre></div>
<p>It would be easier if we can claim that a type <code>t</code> is a union of several types and provides any of these types vaule as a value of type <code>t</code>.</p>
<p>This idea is not new, it’s for example investigated in the <a href="http://hackage.haskell.org/package/open-union"><code>open-union</code></a> package. Thanks to this package, we can replace the first example with something like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Alcohol</span> <span class="fu">=</span> <span class="dt">Union</span> <span class="ch">&#39;[Whisky, Beer]</span>


<span class="ot">myAlcohol ::</span> <span class="dt">Alcohol</span>
myAlcohol <span class="fu">=</span> liftUnion (<span class="dt">Whisky</span> <span class="dv">12</span> <span class="dv">40</span>)</code></pre></div>
<p><code>open-union</code> is a great solution in Haskell. However, it relies on <code>Data.Dynamic</code> which means that we need to carry over the representation of the type.</p>
<h1 id="defining-union-types-in-idris">Defining union types in Idris</h1>
<p><a href="http://www.idris-lang.org/">Idris</a> is a purely functional programming language with dependent-type designed by Edwin Brady. I assume here a basic knowledge of Idris and of dependent types.</p>
<h2 id="declaring-union-types">Declaring union types</h2>
<p>Suppose that you can promote the values as types, how would it helps to build an union type? This question was the one that started the journey.</p>
<p>Here was the idea: we can define a type as a list of type. From there, it suffices to find a way to “point” the valid type in our union and we obtain an union for free. Here is the implementation:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Union</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">MemberHere</span> <span class="ot">:</span> ty <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>ts)
  <span class="dt">MemberThere</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>ts)</code></pre></div>
<p>So, <code>Union</code> is a type that is parametrized by a list of types. For example, with this data declaration, <code>Union [Char, String]</code> is a valid type.</p>
<p>To build members of <code>Union</code> we have two constructors. <code>MemberHere</code> is the easiest. Given a value of type <code>ty</code>, we can build an instance of any <code>Union</code> type such that the list of its composed types starts with <code>ty</code>, whatever are the other types of the union. <code>MemberThere</code> provides a way to prepend other types in our <code>Union</code>. Let’s see these types in action:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">x</span> <span class="ot">:</span> <span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]
x <span class="fu">=</span> <span class="dt">MemberHere</span> <span class="st">&quot;Ahoy!&quot;</span>

<span class="fu">y</span> <span class="ot">:</span> <span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]
x <span class="fu">=</span> <span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> <span class="dv">3</span>)</code></pre></div>
<p>With this basic definitions, we have in hands all we need to create union types. Altough, the instances are really painful to write, even more than with classic sum types.</p>
<p>We can do way better with a small helper:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">member</span> <span class="ot">:</span> ty <span class="ot">-&gt;</span> {<span class="kw">auto</span> e<span class="ot">:</span> <span class="dt">Elem</span> ty ts} <span class="ot">-&gt;</span> <span class="dt">Union</span> ts
member x {e <span class="fu">=</span> <span class="dt">Here</span>} <span class="fu">=</span> <span class="dt">MemberHere</span> x
member x {e <span class="fu">=</span> <span class="dt">There</span> later} <span class="fu">=</span>
  <span class="dt">MemberThere</span> (member x {e <span class="fu">=</span> later})</code></pre></div>
<p>This short function takes advantages of Idris <a href="http://docs.idris-lang.org/en/latest/tutorial/miscellany.html#auto-implicit-arguments">auto implicit arguments</a>, which automatically computes argument at compile times, depending on the executino context. The idea is that, given a type <code>ty</code>, such that <code>ty</code> is in the union, we can compute the location of this type in the union and provide an <code>Elem</code>. This <code>Elem</code> is then used to compute the <code>Union</code> boilerplate. An we obtain:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">x</span> <span class="ot">:</span> <span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]
x <span class="fu">=</span> member <span class="st">&quot;Ahoy!&quot;</span>

<span class="fu">y</span> <span class="ot">:</span> <span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]
x <span class="fu">=</span> member <span class="dv">3</span></code></pre></div>
<p>Note that as complex as the union will be, the instanciation will always straightforward.</p>
<h2 id="extracting-union-type">Extracting union type</h2>
<p>Ok, so union type are easy to declare and to instanciate. We also need an easy way to get our value back if we want to compete with sun types.</p>
<p>Let’s define a <code>get</code> function that extract a value of type <code>ty</code> from an union. To typecheck, <code>ty</code> must be a valid type (a type listed in the union). And we can’t be sure to obtain a <code>ty</code>. Thus, the type of <code>get</code> is:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">get</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> {<span class="kw">auto</span> p<span class="ot">:</span> <span class="dt">Elem</span> ty ts} <span class="ot">-&gt;</span> <span class="dt">Maybe</span> ty</code></pre></div>
<p>And once again, the idea is to use the witness of the type position in the union (<code>p</code>) to compute the answer.</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">get</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> {<span class="kw">auto</span> e<span class="ot">:</span> <span class="dt">Elem</span> ty ts} <span class="ot">-&gt;</span> <span class="dt">Maybe</span> ty
get (<span class="dt">MemberHere</span> x)  {e <span class="fu">=</span> <span class="dt">Here</span>}    <span class="fu">=</span> <span class="dt">Just</span> x
get (<span class="dt">MemberHere</span> x)  {e <span class="fu">=</span> <span class="dt">There</span> <span class="fu">_</span>} <span class="fu">=</span> <span class="dt">Nothing</span>
get (<span class="dt">MemberThere</span> x) {e <span class="fu">=</span> <span class="dt">Here</span>}    <span class="fu">=</span> <span class="dt">Nothing</span>
get (<span class="dt">MemberThere</span> later) {e <span class="fu">=</span> <span class="dt">There</span> l} <span class="fu">=</span>
  get later {e<span class="fu">=</span>l}</code></pre></div>
<p>All these case should be straight forward. And now we can have (in the REPL):</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;&gt;&gt;</span> <span class="ot">:</span><span class="kw">let</span> x <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>, <span class="dt">List</span> <span class="dt">String</span>]) <span class="fu">$</span> member <span class="st">&quot;Ahoy!&quot;</span>
<span class="fu">&gt;&gt;&gt;</span> the (<span class="dt">Maybe</span> <span class="dt">String</span>) <span class="fu">$</span> get x
<span class="dt">Just</span> <span class="st">&quot;Ahoy!&quot;</span> <span class="ot">:</span> <span class="dt">Maybe</span> <span class="dt">String</span>
<span class="fu">&gt;&gt;&gt;</span> the (<span class="dt">Maybe</span> <span class="dt">Nat</span>) <span class="fu">$</span> get x
<span class="dt">Nothing</span> <span class="ot">:</span> <span class="dt">Maybe</span> <span class="dt">Nat</span></code></pre></div>
<p>We uset <code>the</code> here to provide a Type hint, but it won’t be useful in most of the cases, as the type will be provided by the context.</p>
<h1 id="part-1-is-over">Part 1 is over</h1>
<p>That’s all for today, you can continue with the fold for <a href="http://nicolas.biri.name/posts/2016-07-27-union-type-in-idris-part-2.html">union type</a>.</p>
]]></description>
    <pubDate>Tue, 26 Jul 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-07-26-union-type-in-idris-part-1.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>
<item>
    <title>Après les morts</title>
    <link>http://nicolas.biri.name//posts/2015-11-17-Apres-les-morts.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 17, 2015
    
        by Nicolas Biri
    
</div>

<p>Chère France,</p>
<p>Même si les morts sont toujours dans nos pensées, ton deuil prend fin. J’ai attendu cela pour t’écrire, par respect pour toi, malgré la nausée que provoquait chez moi pendant ce temps l’agitation de certains de tes représentants et de tes penseurs.</p>
<p>Que l’horreur est effroyable quand elle est proche de nous ! Je n’ai pas peur, je suis juste empli de tristesse. Triste en pensant à ces innocents qui sont morts évidemment. Triste également en pensant à la haine qui transpire d’une partie de ton peuple, haine qui m’a mis plus d’une fois le cœur au bord des lèvres ces derniers temps.</p>
<p>C’est que, vois-tu, dans toute cette horreur, je n’arrive pas à en vouloir à ceux qui sont morts. Des gens assez faibles pour partir en mission-suicide pour tuer des gens dont ils ne savent rien méritent également à mon avis un peu de compassion. Certains de ces terroristes ont grandi parmi nous, ont vécu dans nos villes, sont allés dans nos écoles, et nous n’avons pas réussi à leur inculquer un minimum de respect de la vie humaine.</p>
<p>Une part non négligeable de notre peuple flirte de manière ouverte avec la haine. Oh, rien de comparable avec la haine qui pousse à tuer des innocents non, juste celle qui crédibilise le discours de ceux qui les embrigadent. Quand j’ai lu la revendication de l’État Islamique, j’ai pensé à Zemmour, au Front National, et aux autres et je me suis dit que leurs mots et leurs gesticulations, en plus de ne résoudre aucun problème, donnent du crédit à ces discours incohérents. La haine nourrit la haine, ce n’est pas nouveau mais cette instance est tellement cruelle qu’elle est dure à supporter.</p>
<p>J’ai peur pour toi, peur que la haine te ronge, de l’extérieur comme de l’intérieur. J’ai peur mais soyons honnêtes, cette peur n’est pas une victoire des terroristes, c’est juste notre défaite.</p>
]]></description>
    <pubDate>Tue, 17 Nov 2015 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2015-11-17-Apres-les-morts.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>

    </channel>
</rss>
